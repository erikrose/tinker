Python-ish but trading some of the little-used dynamicity for speed and machine-code compilation. A good language for prototyping but then runs fast and deploys easily. Easier to reason about than Python and no less terse.

* It compiles to machine code.
* Circular imports are fine. I mean, it might make the build slower and use more RAM, but I'm not going to impose the busywork of toposorting right-the-hell-now if you're in a hurry.
* Scopes (for instance, module top-levels) are immutable
  * So you can do forward references. Toposorting is for computers.
* Fuck colons. I'm always forgetting them. We have line breaks.
* Goal: the only reason to write out a type name for a variable is documentation. Clear cases (at least) should be inferred.
* Everything's an expression (including `if` but maybe not assignment). This gives terseness and simplicity (no special ternary expression needed; can factor an "a = " out of a match clause).
* Still no variable declarations, folks. They're noise to read and bookkeeping to do. Being able to use tighter-scoped vars as a crutch inside a function that should be made shorter anyway is not sufficient justification. Having vars go out of scope as soon as they're no longer used should be a matter for the optimizer (and should matter only for embedded systems). Should we be able to rebind a var to a string later in a function if it was an int earlier?
* Definitely want to be able to pass functions around. (Thus, compile-time call graphs will not always be exhaustive, limiting some optimizations. However, I imagine we can still do optimizations for static function calls.)
* I love iterators. Probably have those.
* Perhaps avoid breaking-returns.
* List comps with filters. Map/reduce. All those things that let you focus syntactically on what you want, not how to get it. Resolve all applicable questions in favor of what lets you focus on what you want rather than how to get it. That's what you care about when trying to understand a program, which is how most time is spent.

* Probably don't autocurry. It makes for confusing error messages for noobs.
* D has GC but lets you turn it off for sections. Study it.

# Types
## Possibilities
? No classes, just typed structs (or interfaces?) and type- (or interface?)-dispatched functions
* ADTs
* Generics through compile-time functors. Or maybe Hindley-Milner makes that pointless.
? Block-structured or function-scoped? Probably the latter. OCaml-style block structuring weirds language, making var bindings start new blocks, which people can't tolerate the indentation of, so then they weird the indentation, and then the block representation has to live in your head, and semicolons crop up in nonobvious places. Function scoping is a nice middleground where you can have an open playground (for fast development and prototyping) but bounded by the limits of the function.

## Deciding among possibilities
* I'd like for things to be retrofittable. IOW, be able to attach new routines to a stdlib type without having to stick new interface declarations in the stdlib.

# Syntax

to add a:int and b:int
    a + b

to count-words str:text
    num = 0
    for char in str do
        if char == ' ' then
            num = num + 1  # Might lower to `set num to (num + 1)`.

to count-words string:text
    sum((if char == ' ' 1 else 0) for char in string, 0)

fn num_words(string str)
    length(char for char in str if char == ' ')

fn sum(iterable Iterable<T>, default T)
    total = 0
    for item in iterable
        total = total + item
    else
        default

fn documented_types(big_doodad:BigDoodad)
    sub_doodad:PigglyWiggly = big_doodad.owner  -- Compiler proves that documented types are right.
